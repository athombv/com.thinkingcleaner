"use strict";

const request = require('request');
const EventEmitter = require('events').EventEmitter;

class ThinkingCleaner extends EventEmitter {

	constructor(options) {
		options = options || {};

		// Call super
		super();

		// Store variables
		this.name = options.name;
		this.ip = options.ip;
		this.id = options.id;
		this.polling = options.polling;

		// Capability variables
		this.battery_charge = undefined;
		this.cleaner_state = undefined;

		// State variables
		this.cleaning = false;
		this.docked = false;
		this.stopped = false;
		this.charging = false;
		this.spot_cleaning = false;

		// Availability
		this.status = true;

		// Start polling for data
		this._dataPolling();

		// Refresh IP every 10 minutes
		this.refreshInterval = setInterval(()=> {
			if (this.polling) this._refreshIP();
		}, 60000 * 10);
	}

	_getStatus() {
		return new Promise((resolve) => {
			this._apiCall("status.json").then(body => {

				// Listen for changes
				if (body.status.battery_charge && body.status.battery_charge !== this.battery_charge && this.battery_charge) {
					console.log("TC: battery change detected: " + body.status.battery_charge);

					this.emit("battery_charge", body.status.battery_charge);
				}

				// Save new values
				this.battery_charge = body.status.battery_charge;

				// Determine state (cleaning/stopped/spot_cleaning/docked)
				let newState = this._determineState(body.status);

				// Check for changes
				if (newState !== this.cleaner_state && newState && this.cleaner_state) {
					console.log("TC: cleaner state change detected: " + newState);

					this.emit("cleaner_state", newState);
				}

				// Detect if tc started cleaning
				if (!this.cleaning && !this.spot_cleaning && this.cleaner_state !== "cleaning" && this.cleaner_state !== "spot_cleaning"
					&& (newState === "cleaning" || newState === "spot_cleaning")) {
					console.log("TC: cleaner started cleaning: " + newState);

					// Emit started cleaning
					this.emit("started_cleaning");
				}

				// Save it
				this.cleaner_state = newState;

				// Set state variable
				this.cleaning = (this.cleaner_state === "cleaning");
				this.docked = (this.cleaner_state === "docked");
				this.stopped = (this.cleaner_state === "stopped");
				this.spot_cleaning = (this.cleaner_state === "spot_cleaning");
				this.charging = (this.cleaner_state === "charging");

				resolve();
			});
		})
	}

	_dataPolling() {
		this._getStatus();

		// Start data polling interval
		this.pollingInterval = setInterval(() => {
			if (this.polling) this._getStatus();
		}, 15000);
	}

	_sendCleanCommand(resolve, reject) {
		this.cleaning = true;
		this.spot_cleaning = false;
		this.stopped = false;
		this.docked = false;
		this.charging = false;

		console.log('TC: send clean command');
		console.log('TC: state:');
		console.log({
			cleaning: this.cleaning,
			docked: this.docked,
			stopped: this.stopped,
			spot_cleaning: this.spot_cleaning,
			charging: this.charging
		});
		this._apiCall("command.json?command=clean").then(() => {

			this.emit("started_cleaning");

			resolve();
		}).catch(() => {
			reject();
		})
	}

	startCleaning() {

		console.log('TC: start cleaning');
		console.log('TC: state:');
		console.log({
			cleaning: this.cleaning,
			docked: this.docked,
			stopped: this.stopped,
			spot_cleaning: this.spot_cleaning,
			charging: this.charging
		});

		return new Promise((resolve, reject) => {
			if (this.cleaning) return reject("already cleaning");
			else if (this.spot_cleaning) this.stopCleaning().then(()=> {

				setTimeout(() => {
					this._sendCleanCommand(resolve, reject)
				}, 1500);
			});
			else {

				this._sendCleanCommand(resolve, reject)
			}
		});
	}

	_sendSpotCleanCommand(resolve, reject) {

		this.cleaning = false;
		this.spot_cleaning = true;
		this.stopped = false;
		this.docked = false;
		this.charging = false;

		console.log('TC: send spot clean command');
		console.log('TC: state:');
		console.log({
			cleaning: this.cleaning,
			docked: this.docked,
			stopped: this.stopped,
			spot_cleaning: this.spot_cleaning,
			charging: this.charging
		});

		this._apiCall("command.json?command=spot").then(() => {

			this.emit("started_cleaning");

			resolve();
		}).catch(() => {
			reject();
		})
	}

	startSpotCleaning() {

		console.log('TC: start spot cleaning');
		console.log('TC: state:');
		console.log({
			cleaning: this.cleaning,
			docked: this.docked,
			stopped: this.stopped,
			spot_cleaning: this.spot_cleaning,
			charging: this.charging
		});

		return new Promise((resolve, reject) => {
			if (this.spot_cleaning) return reject("already spot cleaning");
			else if (this.cleaning) this.stopCleaning().then(()=> {
				setTimeout(() => {
					this._sendSpotCleanCommand(resolve, reject)
				}, 1500);
			});
			else {
				this._sendSpotCleanCommand(resolve, reject)
			}
		});
	}

	stopCleaning() {
		return new Promise((resolve, reject) => {
			if (this.cleaning || this.spot_cleaning) {

				this.cleaning = false;
				this.spot_cleaning = false;
				this.stopped = true;
				this.docked = false;
				this.charging = false;

				console.log('TC: stop cleaning');
				console.log('TC: state:');
				console.log({
					cleaning: this.cleaning,
					docked: this.docked,
					stopped: this.stopped,
					spot_cleaning: this.spot_cleaning,
					charging: this.charging
				});

				this._apiCall("command.json?command=clean").then(() => {

					resolve();
				}).catch(() => {
					reject();
				})
			} else resolve();
		});
	}

	goToDock() {
		console.log("TC: send stop go to dock command");

		return this._apiCall("command.json?command=dock");
	}

	playSound() {
		console.log("TC: send find me command");

		return this._apiCall("command.json?command=find_me");
	}

	_determineState(status) {
		switch (status.cleaner_state) {
			case "st_stopped":
				return "stopped";
			case "st_cleanstop":
				return "stopped";
			case "st_clean_spot":
				return "spot_cleaning";
			case "st_clean_max":
				return "cleaning";
			case "st_clean":
				return "cleaning";
			case "st_base":
				return "docked";
			case "st_base_recon":
				return "charging";
			case "st_base_full":
				return "docked";
			case "st_base_trickle":
				return "charging";
			default:
				return "stopped";
		}
	}

	_apiCall(command) {
		return new Promise((resolve, reject) => {
			request(`http://${this.ip}/${command}`, { method: "GET", timeout: 10000 }, (error, response, body) => {
				if (!error && body) {

					try {
						// Parse response
						body = JSON.parse(body);
					} catch (err) {
						console.error('TC: Error, failed to parse incoming discovery data');
						body = null;
					}
				}

				if (!error && body && body.result === "success") {

					// Emit as available if prev state was unavailable
					if (!this.status) {
						this.emit("available");
						this.status = true;
					}

					// Resolve with result
					resolve(body)
				}
				else {

					// Mark as unavailable if prev state was available
					if (this.status) {
						this.emit("unavailable");
						this.status = false;
					}

					console.log("TC: request error " + error);

					// Reject
					reject(error)
				}
			})
		});
	}

	stopListening() {
		this.polling = false;
		if (this.pollingInterval) clearInterval(this.pollingInterval);
		if (this.refreshInterval) clearInterval(this.refreshInterval);
	}

	_refreshIP() {

		// Make request
		request("http://thinkingsync.com/api/v1/discover/devices", { timeout: 15000 }, (error, response, body) => {
			if (error) return;

			let devices;

			try {
				// Parse response
				devices = JSON.parse(body);
			} catch (err) {
				console.error('TC: Error, failed to parse incoming discovery data');
			}

			// If data is present
			if (devices) {

				// Loop the devices
				for (let i in devices) {

					// Find this device
					if (devices[i].uuid === this.id) {

						// Update IP address
						this.ip = devices[i].local_ip
					}
				}
			}
		});
	}
}

module.exports = ThinkingCleaner;